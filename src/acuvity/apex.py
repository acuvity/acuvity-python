"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from acuvity import models, utils
from acuvity._hooks import HookContext
from acuvity.types import BaseModel, OptionalNullable, UNSET
from acuvity.utils import get_security_from_env
from acuvity.utils.unmarshal_json_response import unmarshal_json_response
from typing import Any, List, Mapping, Optional, Union, cast

# region imports
import base64
import os
from pathlib import Path

# pylint: disable=ungrouped-imports
from typing import Dict, Iterable, Sequence

from acuvity.guard.config import Guard, GuardConfig, GuardName
from acuvity.models import (
    Analyzer,
    Anonymization,
    Extractionrequest,
    Scanrequest,
    Type,
)
from acuvity.response.match import ScanResponseMatch
from acuvity.utils.logger import get_default_logger

logger = get_default_logger()
# endregion imports


class Apex(BaseSDK):
    r"""This tag is for group 'apex'"""

    # region sdk-class-body
    _available_analyzers: Optional[List[Analyzer]] = None

    def list_available_guards(self) -> List[str]:
        """
        list_available_guards: returns a list of all available guards that can be detected.
        """
        return GuardName.values()

    def list_detectable_secrets(self) -> List[str]:
        """
        list_detectable_secrets: returns a list of all available secrets that can be detected.
        """
        detectable_secrets: List[str] = []
        if self._available_analyzers is None:
            self._available_analyzers = self.list_analyzers()
        for analyzer in self._available_analyzers:
            if analyzer.detectors:
                detectable_secrets_local = [
                    str(detector.name)
                    for detector in analyzer.detectors
                    if detector.group == "Secrets"
                ]
                detectable_secrets.extend(detectable_secrets_local)
        return sorted(list(set(detectable_secrets)))

    def list_detectable_piis(self) -> List[str]:
        """
        list_detectable_piis: returns a list of all available Piis that can be detected.
        """
        detectable_piis: List[str] = []
        if self._available_analyzers is None:
            self._available_analyzers = self.list_analyzers()
        for analyzer in self._available_analyzers:
            if analyzer.detectors:
                detectable_piis_local = [
                    str(detector.name)
                    for detector in analyzer.detectors
                    if detector.group == "PIIs"
                ]
                detectable_piis.extend(detectable_piis_local)
        return sorted(list(set(detectable_piis)))

    def scan(
        self,
        *messages: str,
        files: Union[Sequence[Union[str, os.PathLike]], os.PathLike, str, None] = None,
        request_type: Union[Type, str] = Type.INPUT,
        annotations: Optional[Dict[str, str]] = None,
        redactions: Optional[List[str]] = None,
        keywords: Optional[List[str]] = None,
        guard_config: Optional[Union[str, Path, Dict, List[Guard]]] = None,
    ) -> ScanResponseMatch:
        """
        scan() runs the provided messages (prompts) through the Acuvity detection engines and returns the results. Alternatively, you can run model output through the detection engines.
        Returns a Scanresponse object on success, and raises different exceptions on failure.

        This function allows to use and try different analyzers and make use of the redaction feature.
        You can also run access policies and content policies by passing them as parameters.

        :param messages: the messages to scan. These are the prompts that you want to scan. Required if no files or a direct request object are provided.
        :param files: the files to scan. These are the files that you want to scan. Required if no messages are provided. Can be used in addition to messages.
        :param request_type: the type of the validation. This can be either Type.INPUT or Type.OUTPUT. Defaults to Type.INPUT. Use Type.OUTPUT if you want to run model output through the detection engines.
        :param annotations: the annotations to use. These are the annotations that you want to use. If not provided, no annotations will be used.
        :param redactions: the redactions that need to be redacted if detected. This arg cannot be used with guard_config.
        :param keywords: the keywords that need to be detected. This arg cannot be used with guard_config.
        :param guard_config: the guard config used to do the response eval for matches. If not provided, the default guard config will be used.
        """

        raw_scan_response = self.scan_request(
            request=self.__build_scan_request(
                *messages,
                files=files,
                request_type=request_type,
                annotations=annotations,
                redactions=redactions,
                keywords=keywords,
                guard_config=(
                    guard_config if guard_config is None else GuardConfig(guard_config)
                ),
            )
        )

        # always send a guard config to the ScanResponseMatch
        try:
            if guard_config:
                gconfig = GuardConfig(guard_config)
            else:
                gconfig = GuardConfig()
        except Exception as e:
            logger.debug("Error while processing the guard config")
            raise ValueError("Cannot process the guard config") from e

        return ScanResponseMatch(raw_scan_response, gconfig, files=files)

    async def scan_async(
        self,
        *messages: str,
        files: Union[Sequence[Union[str, os.PathLike]], os.PathLike, str, None] = None,
        request_type: Union[Type, str] = Type.INPUT,
        annotations: Optional[Dict[str, str]] = None,
        redactions: Optional[List[str]] = None,
        keywords: Optional[List[str]] = None,
        guard_config: Optional[Union[str, Path, Dict, List[Guard]]] = None,
    ) -> ScanResponseMatch:
        """
        scan_async() runs the provided messages (prompts) through the Acuvity detection engines and returns the results. Alternatively, you can run model output through the detection engines.
        Returns a Scanresponse object on success, and raises different exceptions on failure.

        This function allows to use and try different analyzers and make use of the redaction feature.
        You can also run access policies and content policies by passing them as parameters.

        :param messages: the messages to scan. These are the prompts that you want to scan. Required if no files or a direct request object are provided.
        :param files: the files to scan. These are the files that you want to scan. Required if no messages are provided. Can be used in addition to messages.        :param request_type: the type of the validation. This can be either Type.INPUT or Type.OUTPUT. Defaults to Type.INPUT. Use Type.OUTPUT if you want to run model output through the detection engines.
        :param annotations: the annotations to use. These are the annotations that you want to use. If not provided, no annotations will be used.
        :param analyzers: the analyzers to use. These are the analyzers that you want to use. If not provided, the internal default analyzers will be used. Use "+" to include an analyzer and "-" to exclude an analyzer. For example, ["+image-classifier", "-modality-detector"] will include the image classifier and exclude the modality detector. If any analyzer does not start with a '+' or '-', then the default analyzers will be replaced by whatever is provided. Call `list_analyzers()` and/or its variants to get a list of available analyzers.
        :param guard_config: the guard config used to do the response eval for matches. If not provided, the default guard config will be used.
        """
        raw_scan_response = await self.scan_request_async(
            request=self.__build_scan_request(
                *messages,
                files=files,
                request_type=request_type,
                annotations=annotations,
                redactions=redactions,
                keywords=keywords,
                guard_config=(
                    guard_config if guard_config is None else GuardConfig(guard_config)
                ),
            )
        )
        # always send a guard config to the ScanResponseMatch
        try:
            if guard_config:
                gconfig = GuardConfig(guard_config)
            else:
                gconfig = GuardConfig()
        except Exception as e:
            logger.debug("Error while processing the guard config")
            raise ValueError("Cannot process the guard config") from e

        return ScanResponseMatch(raw_scan_response, gconfig, files=files)

    def __build_scan_request(
        self,
        *messages: str,
        files: Union[Sequence[Union[str, os.PathLike]], os.PathLike, str, None] = None,
        request_type: Union[Type, str] = Type.INPUT,
        annotations: Optional[Dict[str, str]] = None,
        redactions: Optional[List[str]] = None,
        keywords: Optional[List[str]] = None,
        anonymization: Union[Anonymization, str, None] = None,
        guard_config: Optional[GuardConfig] = None,
    ) -> Scanrequest:
        request = Scanrequest.model_construct()

        # if guard_config is given, the keywords and redactions args must not be given.
        if guard_config and (keywords or redactions):
            raise ValueError(
                "Cannot specify keywords or redactions in scan args when using guard config. Please use only one."
            )

        # messages must be strings
        for message in messages:
            if not isinstance(message, str):
                raise ValueError(f"messages must be strings but was {type(message)}")
        if len(messages) == 0 and files is None:
            raise ValueError("no messages and no files provided")
        if len(messages) > 0:
            request.messages = list(messages)

        # files must be a list of strings (or paths) or a single string (or path)
        extractions: List[Extractionrequest] = []
        if files is not None:
            process_files: List[Union[os.PathLike, str]] = []
            if isinstance(files, str):
                process_files.append(files)
            elif isinstance(files, os.PathLike):
                process_files.append(files)
            elif isinstance(files, Iterable):
                for file in files:
                    if not isinstance(file, str) and not isinstance(file, os.PathLike):
                        raise ValueError("files must be strings or paths")
                    process_files.append(file)
            else:
                raise ValueError("files must be strings or paths")
            for process_file in process_files:
                with open(process_file, "rb") as opened_file:
                    file_content = opened_file.read()
                    # base64 encode the file content and then append
                    extractions.append(
                        Extractionrequest(
                            data=base64.b64encode(file_content).decode("utf-8"),
                        )
                    )
        if len(extractions) > 0:
            request.extractions = extractions

        # request_type must be either "Input" or "Output"
        if isinstance(request_type, Type):
            request.type = request_type
        elif isinstance(request_type, str):
            if request_type not in ("Input", "Output"):
                raise ValueError("request_type must be either 'Input' or 'Output'")
            request.type = Type(request_type)
        else:
            raise ValueError("type must be a 'str' or 'Type'")

        # annotations must be a dictionary of strings
        if annotations is not None:
            if not isinstance(annotations, dict):
                raise ValueError("annotations must be a dictionary")
            for key, value in annotations.items():
                if not isinstance(key, str) or not isinstance(value, str):
                    raise ValueError("annotations must be strings")
            request.annotations = annotations

        # now here check the guard config and parse it for the redaction and keywords.
        if guard_config:
            keywords = guard_config.keywords
            redactions = guard_config.redaction_keys

        # anonymization must be "FixedSize" or "VariableSize"
        if anonymization is not None:
            if isinstance(anonymization, Anonymization):
                request.anonymization = anonymization
            elif isinstance(anonymization, str):
                if anonymization not in ("FixedSize", "VariableSize"):
                    raise ValueError(
                        "anonymization must be 'FixedSize' or 'VariableSize'"
                    )
                request.anonymization = Anonymization(anonymization)
            else:
                raise ValueError("anonymization must be a 'str' or 'Anonymization'")

        # redactions must be a list of strings
        if redactions is not None:
            if not isinstance(redactions, List):
                raise ValueError("redactions must be a list")
            for redaction in redactions:
                if not isinstance(redaction, str):
                    raise ValueError("redactions must be strings")
            request.redactions = redactions

        # keywords must be a list of strings
        if keywords is not None:
            if not isinstance(keywords, List):
                raise ValueError("keywords must be a list")
            for keyword in keywords:
                if not isinstance(keyword, str):
                    raise ValueError("keywords must be strings")
            request.keywords = keywords

        return request

    # endregion sdk-class-body

    def list_analyzers(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.Analyzer]:
        r"""List of all available analyzers.

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 60000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request(
            method="GET",
            path="/_acuvity/analyzers",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(1000, 60000, 1.5, 300000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["408", "423", "429", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get-all-Analyzers",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.Analyzer], http_res)
        if utils.match_response(http_res, ["400", "401"], "application/json"):
            response_data = unmarshal_json_response(models.ElementalerrorData, http_res)
            raise models.Elementalerror(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(models.ElementalerrorData, http_res)
            raise models.Elementalerror(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    async def list_analyzers_async(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.Analyzer]:
        r"""List of all available analyzers.

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 60000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request_async(
            method="GET",
            path="/_acuvity/analyzers",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(1000, 60000, 1.5, 300000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["408", "423", "429", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get-all-Analyzers",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.Analyzer], http_res)
        if utils.match_response(http_res, ["400", "401"], "application/json"):
            response_data = unmarshal_json_response(models.ElementalerrorData, http_res)
            raise models.Elementalerror(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(models.ElementalerrorData, http_res)
            raise models.Elementalerror(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    def scan_request(
        self,
        *,
        request: Union[models.Scanrequest, models.ScanrequestTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Scanresponse:
        r"""Processes the scan request.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 60000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.Scanrequest)
        request = cast(models.Scanrequest, request)

        req = self._build_request(
            method="POST",
            path="/_acuvity/scan",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.Scanrequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(1000, 60000, 1.5, 300000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["408", "423", "429", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="create-ScanRequest-as-ScanResponse",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "415",
                "422",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Scanresponse, http_res)
        if utils.match_response(
            http_res, ["400", "403", "415", "422"], "application/json"
        ):
            response_data = unmarshal_json_response(models.ElementalerrorData, http_res)
            raise models.Elementalerror(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(models.ElementalerrorData, http_res)
            raise models.Elementalerror(response_data, http_res)
        if utils.match_response(http_res, ["401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    async def scan_request_async(
        self,
        *,
        request: Union[models.Scanrequest, models.ScanrequestTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Scanresponse:
        r"""Processes the scan request.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 60000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.Scanrequest)
        request = cast(models.Scanrequest, request)

        req = self._build_request_async(
            method="POST",
            path="/_acuvity/scan",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.Scanrequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(1000, 60000, 1.5, 300000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["408", "423", "429", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="create-ScanRequest-as-ScanResponse",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "415",
                "422",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Scanresponse, http_res)
        if utils.match_response(
            http_res, ["400", "403", "415", "422"], "application/json"
        ):
            response_data = unmarshal_json_response(models.ElementalerrorData, http_res)
            raise models.Elementalerror(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(models.ElementalerrorData, http_res)
            raise models.Elementalerror(response_data, http_res)
        if utils.match_response(http_res, ["401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)
